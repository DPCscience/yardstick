% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/autoplot.R, R/probs.R
\name{autoplot.roc_df}
\alias{autoplot.roc_df}
\alias{roc_auc}
\alias{roc_auc.data.frame}
\alias{roc_auc_vec}
\alias{mn_log_loss}
\alias{mn_log_loss.data.frame}
\alias{mn_log_loss_vec}
\alias{roc_curve}
\alias{roc_curve.data.frame}
\title{Metrics Based on Class Probabilities}
\usage{
autoplot.roc_df(object, ...)

roc_auc(data, ...)

\method{roc_auc}{data.frame}(data, truth, ..., options = list(),
  estimator = NULL, na.rm = TRUE)

roc_auc_vec(truth, estimate, options = list(), estimator = NULL,
  na.rm = TRUE, ...)

mn_log_loss(data, ...)

\method{mn_log_loss}{data.frame}(data, truth, ..., na.rm = TRUE,
  sum = FALSE)

mn_log_loss_vec(truth, estimate, na.rm = TRUE, sum = FALSE, ...)

roc_curve(data, ...)

\method{roc_curve}{data.frame}(data, truth, ..., options = list(),
  na.rm = TRUE)
}
\arguments{
\item{...}{A set of unquoted column names or one or more
\code{dplyr} selector functions to choose which variables contain the
class probabilities. If \code{truth} is binary, only 1 column should be selected.
Otherwise, there should be as many columns as factor levels of \code{truth}.}

\item{data}{A \code{data.frame} containing the \code{truth} and \code{estimate}
columns.}

\item{truth}{The column identifier for the true class results
(that is a \code{factor}). This should be an unquoted column name although
this argument is passed by expression and supports
\link[rlang:quasiquotation]{quasiquotation} (you can unquote column
names). For \code{_vec()} functions, a \code{factor} vector.}

\item{options}{A \code{list} of named options to pass to \code{\link[=roc]{roc()}}
such as \code{direction} or \code{smooth}. These options should not include \code{response},
\code{predictor}, or \code{levels}.}

\item{estimator}{For \code{roc_auc()} and \code{pr_auc()}, one of \code{"binary"},
\code{"macro"}, or \code{"macro_weighted"} to specify the type of averaging to be done.
\code{"binary"} is only relevant for the two class case. The other two are
general methods for calculating multiclass metrics. The default will
automatically choose \code{"binary"} or \code{"macro"} based on \code{truth}. \code{roc_auc()}
also accepts \code{"hand_till"} for the metric described in Hand, Till (2001).}

\item{na.rm}{A \code{logical} value indicating whether \code{NA}
values should be stripped before the computation proceeds.}

\item{estimate}{If \code{truth} is binary, a numeric vector of class probabilities
corresponding to the "relevant" class. Otherwise, a matrix with as many
columns as factor levels of \code{truth}.}

\item{sum}{A \code{logical}. Should the sum of the likelihood contributions be
returned (instead of the mean value)?}
}
\value{
For \code{roc_curve()}, a tibble with columns
\code{sensitivity} and \code{specificity}. If an ordinary (i.e. non-smoothed) curve
is used, there is also a column for \code{.threshold}.

For \code{roc_curve()} and \code{pr_curve()}, if a multiclass \code{truth} column is
provided, a one-vs-all approach will be taken to calculate multiple curves,
one per level. In this case, there will be an additional column, \code{.level},
identifying the "one" column in the one-vs-all calculation.
}
\description{
These functions compute the areas under the receiver operating
characteristic (ROC) curve (\code{roc_auc()}), or the multinomial log loss (\code{mn_log_loss()}). The actual ROC
curve can be created using \code{roc_curve()}.
}
\details{
\code{roc_curve()} computes the sensitivity at every unique
value of the probability column (in addition to infinity and
minus infinity). If a smooth ROC curve was produced, the unique
observed values of the specificity are used to create the curve
points. In either case, this may not be efficient for large data
sets.

\code{pr_curve()} computes the precision at every unique value of the
probability column (in addition to infinity).

The output of both \code{roc_curve()} and \code{pr_curve()} have \code{\link[ggplot2:autoplot]{ggplot2::autoplot()}}
methods for quickly visualizing their curves. These methods work for
binary and multiclass output, and also work with grouped data (i.e. from
resamples). See the examples.
}
\examples{
library(tidyselect)

data("two_class_example")
prob_cols <- levels(two_class_example$truth)

roc_auc(two_class_example, truth = truth, Class1)

library(ggplot2)
library(dplyr)

# Visualize the curve using ggplot2 manually
roc_curve(two_class_example, truth, Class1) \%>\%
  ggplot(aes(x = 1 - specificity, y = sensitivity)) +
  geom_path() +
  geom_abline(lty = 3) +
  coord_equal() +
  theme_bw()

# Or use the autoplot method
autoplot(roc_curve(two_class_example, truth, Class1))


# passing options via a list and _not_ `...`
roc_auc(two_class_example, truth = truth, Class1,
        options = list(smooth = TRUE))

pr_auc(two_class_example, truth, Class1)

# Supply `...` with quasiquotation
mn_log_loss(two_class_example, truth, Class1)
mn_log_loss(two_class_example, truth, !! prob_cols[1])

# Multiclass one-vs-all approach with roc_curve()
# One curve per level
hpc_cv \%>\%
  filter(Resample == "Fold01") \%>\%
  roc_curve(obs, VF:L) \%>\%
  autoplot()

# Same as above, but will all of the resamples
hpc_cv \%>\%
  group_by(Resample) \%>\%
  roc_curve(obs, VF:L) \%>\%
  autoplot()

}
\seealso{
\code{\link[=conf_mat]{conf_mat()}}, \code{\link[=summary.conf_mat]{summary.conf_mat()}}, \code{\link[=recall]{recall()}}, \code{\link[=mcc]{mcc()}}
}
\keyword{manip}
