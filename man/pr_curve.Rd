% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/prob-pr_curve.R, R/autoplot.R
\name{pr_curve}
\alias{pr_curve}
\alias{pr_curve.data.frame}
\alias{pr_auc}
\alias{pr_auc.data.frame}
\alias{pr_auc_vec}
\alias{autoplot.pr_df}
\title{Precision recall curve}
\usage{
pr_curve(data, ...)

\method{pr_curve}{data.frame}(data, truth, ..., na.rm = TRUE)

pr_auc(data, ...)

\method{pr_auc}{data.frame}(data, truth, ..., estimator = NULL,
  na.rm = TRUE)

pr_auc_vec(truth, estimate, estimator = NULL, na.rm = TRUE, ...)

autoplot.pr_df(object, ...)
}
\arguments{
\item{data}{A \code{data.frame} containing the \code{truth} and \code{estimate}
columns.}

\item{...}{A set of unquoted column names or one or more
\code{dplyr} selector functions to choose which variables contain the
class probabilities. If \code{truth} is binary, only 1 column should be selected.
Otherwise, there should be as many columns as factor levels of \code{truth}.}

\item{truth}{The column identifier for the true class results
(that is a \code{factor}). This should be an unquoted column name although
this argument is passed by expression and supports
\link[rlang:quasiquotation]{quasiquotation} (you can unquote column
names). For \code{_vec()} functions, a \code{factor} vector.}

\item{na.rm}{A \code{logical} value indicating whether \code{NA}
values should be stripped before the computation proceeds.}

\item{estimator}{One of \code{"binary"}, \code{"macro"}, or \code{"macro_weighted"} to
specify the type of averaging to be done. \code{"binary"} is only relevant for
the two class case. The other two are general methods for calculating
multiclass metrics. The default will automatically choose \code{"binary"} or
\code{"macro"} based on \code{truth}.}

\item{estimate}{If \code{truth} is binary, a numeric vector of class probabilities
corresponding to the "relevant" class. Otherwise, a matrix with as many
columns as factor levels of \code{truth}.}

\item{object}{The data frame returned from \code{pr_curve()}.}
}
\value{
A \code{tibble} with columns \code{.metric}, \code{.estimator},
and \code{.estimate} and 1 row of values.

For grouped data frames, the number of rows returned will be the same as
the number of groups.

For \code{pr_auc_vec()}, a single \code{numeric} value (or \code{NA}).

For \code{pr_curve()}, a tibble with class \code{pr_df} or \code{pr_grouped_df} having
columns \code{recall}, \code{precision}, and \code{.threshold}.
}
\description{
\code{pr_curve()} constructs the full precision recall curve and returns a
tibble. \code{pr_auc()} is a metric that computes the area under the precision
recall curve.
}
\details{
For \code{pr_curve()}, if a multiclass \code{truth} column is provided, a one-vs-all
approach will be taken to calculate multiple curves, one per level.
In this case, there will be an additional column, \code{.level},
identifying the "one" column in the one-vs-all calculation.
}
\section{Multiclass}{


Macro and macro-weighted averaging is available for this metric.
The default is to select macro averaging if a \code{truth} factor with more
than 2 levels is provided. Otherwise, a standard binary calculation is done.
See \code{vignette("multiclass", "yardstick")} for more information.
}

\examples{
# PR Curve examples ---------------------------------------------------------
library(ggplot2)

# Two class
pr_curve(two_class_example, truth, Class1) \%>\%
  ggplot(aes(x = recall, y = precision)) +
  geom_path() +
  coord_equal() +
  theme_bw()

# Or use autoplot
autoplot(pr_curve(two_class_example, truth, Class1))

# Multiclass one-vs-all approach
# One curve per level
hpc_cv \%>\%
  filter(Resample == "Fold01") \%>\%
  pr_curve(obs, VF:L) \%>\%
  autoplot()

# Same as above, but will all of the resamples
hpc_cv \%>\%
  group_by(Resample) \%>\%
  pr_curve(obs, VF:L) \%>\%
  autoplot()

# PR AUC examples -----------------------------------------------------------

# Two class
data("two_class_example")
pr_auc(two_class_example, truth, Class1)

# Multiclass
library(dplyr)
data(hpc_cv)

# You can use the col1:colN tidyselect syntax
hpc_cv \%>\%
  filter(Resample == "Fold01") \%>\%
  pr_auc(obs, VF:L)

# Groups are respected
hpc_cv \%>\%
  group_by(Resample) \%>\%
  pr_auc(obs, VF:L)

# Weighted macro averaging
hpc_cv \%>\%
  group_by(Resample) \%>\%
  pr_auc(obs, VF:L, estimator = "macro_weighted")

# Vector version
# Supply a matrix of class probabilities
fold1 <- hpc_cv \%>\%
  filter(Resample == "Fold01")

pr_auc_vec(
   truth = fold1$obs,
   matrix(
     c(fold1$VF, fold1$F, fold1$M, fold1$L),
     ncol = 4
   )
)

}
\seealso{
Other class probability metrics: \code{\link{gain_capture}}
}
\author{
Max Kuhn
}
\concept{class probability metrics}
