% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/autoplot.R, R/gain-lift.R
\name{autoplot.gain_df}
\alias{autoplot.gain_df}
\alias{autoplot.lift_df}
\alias{gain_curve}
\alias{lift_curve}
\alias{gain_capture}
\alias{gain_curve.data.frame}
\alias{lift_curve.data.frame}
\alias{gain_capture.data.frame}
\title{Cumulative gain and lift charts}
\usage{
autoplot.gain_df(object, ...)

autoplot.lift_df(object, ...)

gain_curve(data, ...)

\method{gain_curve}{data.frame}(data, truth, ..., na.rm = TRUE)

lift_curve(data, ...)

\method{lift_curve}{data.frame}(data, truth, ..., na.rm = TRUE)

gain_capture(data, ...)

\method{gain_capture}{data.frame}(data, truth, ..., estimator = NULL,
  na.rm = TRUE)
}
\arguments{
\item{object}{The data frame output of \code{gain_curve()} or \code{lift_curve()}
to plot.}

\item{...}{A set of unquoted column names or one or more
\code{dplyr} selector functions to choose which variables contain the
class probabilities. If \code{truth} is binary, only 1 column should be selected.
Otherwise, there should be as many columns as factor levels of \code{truth}.}

\item{data}{A \code{data.frame} containing the \code{truth} and \code{estimate}
columns.}

\item{truth}{The column identifier for the true class results
(that is a \code{factor}). This should be an unquoted column name although
this argument is passed by expression and supports
\link[rlang:quasiquotation]{quasiquotation} (you can unquote column
names). For \code{_vec()} functions, a \code{factor} vector.}

\item{na.rm}{A \code{logical} value indicating whether \code{NA}
values should be stripped before the computation proceeds.}

\item{estimator}{One of \code{"binary"}, \code{"macro"}, or \code{"macro_weighted"} to
specify the type of estimator to be done. \code{"binary"} is only relevant for
the two class case. The other two are general methods for calculating
multiclass metrics. The default will automatically choose \code{"binary"} or
\code{"macro"} based on \code{truth}.}
}
\description{
\code{gain_curve()} calculates the information required for cumulative gain charts,
and \code{lift_curve()} calculates the information for lift charts. Both are visual
aids for measuring model performance. \code{gain_capture()} is a measure of
performance similar to an AUC calculation.
}
\details{
The motivation behind cumulative gain and lift charts is as a visual method to
determine the effectiveness of a model when compared to the results one
might expect without a model. As an example, without a model, if you were
to advertise to a random 10\% of your customer base, then you might expect
to capture 10\% of the of the total number of positive responses had you
advertised to your entire customer base. Given a model that predicts
which customers are more likely to respond, the hope is that you can more
accurately target 10\% of your customer base and capture
>10\% of the total number of positive responses.

The calculation to construct gain and lift curves is as follows:
\enumerate{
\item \code{truth} and \code{estimate} are placed in descending order by the \code{estimate}
values. (\code{estimate} here is a single column supplied in \code{...})
\item The cumulative number of samples with true results relative to the
entire number of true results are found. This is the y-axis in a gain chart.
\item The cumulative \% found is divided by the cumulative \% tested
to construct the lift value. This ratio represents the factor of improvement
over an uninformed model. Values >1 represent a valuable model. This is the
y-axis of the lift chart.
}

The greater the area between the gain curve and the baseline, the better
the model.

The output of \code{gain_curve()} and \code{lift_curve()} both have
\code{\link[ggplot2:autoplot]{ggplot2::autoplot()}} methods for easy visualization. See the examples.

For \code{gain_curve()} and \code{lift_curve()}, if a multiclass \code{truth} column is
provided, a one-vs-all approach will be taken to calculate multiple curves,
one per level. In this case, there will be an additional column, \code{.level},
identifying the "one" column in the one-vs-all calculation.

\code{gain_capture()} calculates the area \emph{under} the gain curve, but \emph{above}
the baseline, and then divides that by the area \emph{under} a perfect gain curve,
but \emph{above} the baseline. It is meant to represent the amount of potential
gain "captured" by the model.

There is no common convention on which factor level should
automatically be considered the "relevant" or "positive" results.
In \code{yardstick}, the default is to use the \emph{first} level. To
change this, a global option called \code{yardstick.event_first} is
set to \code{TRUE} when the package is loaded. This can be changed
to \code{FALSE} if the last level of the factor is considered the
level of interest.
}
\examples{
library(ggplot2)
data(two_class_example)

# Calculate the cumulative gain information given a 2 class factor
# and the corresponding predicted class probabilities
gn <- gain_curve(two_class_example, truth, Class1)

# Plot it
autoplot(gn)

# Similar calculation, but for lift
lif <- lift_curve(two_class_example, truth, Class1)

autoplot(lif)

gain_capture(two_class_example, truth, Class1)

# Visually, this represents the area under the black curve, but above the
# 45 degree dotted line, divided by the area of the shaded triangle.
library(ggplot2)
autoplot(gain_curve(two_class_example, truth, Class1))

}
