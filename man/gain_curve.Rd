% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gain-lift.R
\name{gain_curve}
\alias{gain_curve}
\alias{lift_curve}
\alias{gain_capture}
\alias{gain_curve.data.frame}
\alias{lift_curve.data.frame}
\alias{autoplot.gain_df}
\alias{autoplot.lift_df}
\alias{gain_capture.data.frame}
\title{Cumulative gain and lift charts}
\usage{
gain_curve(data, ...)

\method{gain_curve}{data.frame}(data, truth, estimate, na.rm = TRUE, ...)

lift_curve(data, ...)

\method{lift_curve}{data.frame}(data, truth, estimate, na.rm = TRUE, ...)

\method{autoplot}{gain_df}(object, ...)

\method{autoplot}{lift_df}(object, ...)

gain_capture(data, ...)

\method{gain_capture}{data.frame}(data, truth, estimate, na.rm = TRUE,
  ...)
}
\arguments{
\item{data}{A \code{data.frame} containing the truth and estimate columns.}

\item{...}{Not currently used.}

\item{truth}{The column identifier for the true class results
(that is a \code{factor}). This should be an unquoted column name although this
argument is passed by expression and supports
\link[rlang:quasiquotation]{quasiquotation} (you can unquote column names).}

\item{estimate}{The column identifier for the predicted class probabilities
(that is a \code{numeric}) corresponding to the "positive" result. See Details.}

\item{na.rm}{A \code{logical} value indicating whether \code{NA}
values should be stripped before the computation proceeds.}

\item{object}{The data frame output of \code{gain_curve()} or \code{lift_curve()}
to plot.}
}
\description{
\code{gain_curve()} calculates the information required for cumulative gain charts,
and \code{lift_curve()} calculates the information for lift charts. Both are visual
aids for measuring model performance.
}
\details{
The motivation behind cumulative gain and lift charts is as a visual method to
determine the effectiveness of a model when compared to the results one
might expect without a model. As an example, without a model, if you were
to advertise to a random 10\% of your customer base, then you might expect
to capture 10\% of the of the total number of positive responses had you
advertised to your entire customer base. Given a model that predicts
which customers are more likely to respond, the hope is that you can more
accurately target 10\% of your customer base and capture
>10\% of the total number of positive responses.

The calculation to construct gain and lift curves is as follows:
\enumerate{
\item \code{truth} and \code{estimate} are placed in descending order by the \code{estimate}
values.
\item The cumulative number of samples with true results relative to the
entire number of true results are found. This is the y-axis in a gain chart.
\item The cumulative \% found is divided by the cumulative \% tested
to construct the lift value. This ratio represents the factor of improvement
over an uninformed model. Values >1 represent a valuable model. This is the
y-axis of the lift chart.
}

The greater the area between the gain curve and the baseline, the better
the model.

The output of \code{gain_curve()} and \code{lift_curve()} both have \code{\link[ggplot2:autoplot]{ggplot2::autoplot()}} methods
for easy visualization.

\code{gain_capture()} calculates the area \emph{under} the gain curve, but \emph{above}
the baseline, and then divides that by the area \emph{under} a perfect gain curve,
but \emph{above} the baseline. It is meant to represent the amount of potential
gain "captured" by the model.

There is no common convention on which factor level should
automatically be considered the "relevant" or "positive" results.
In \code{yardstick}, the default is to use the \emph{first} level. To
change this, a global option called \code{yardstick.event_first} is
set to \code{TRUE} when the package is loaded. This can be changed
to \code{FALSE} if the last level of the factor is considered the
level of interest.
}
\examples{
library(ggplot2)
data(two_class_example)

# Calculate the cumulative gain information given a 2 class factor
# and the corresponding predicted class probabilities
gn <- gain_curve(two_class_example, truth, Class1)

# Plot it
autoplot(gn)

# Similar calculation, but for lift
lif <- lift_curve(two_class_example, truth, Class1)

autoplot(lif)

gain_capture(two_class_example, truth, Class1)

# Visually, this represents the area under the black curve, but above the
# 45 degree dotted line, divided by the area of the shaded triangle.
library(ggplot2)
autoplot(gain_curve(two_class_example, truth, Class1))

}
